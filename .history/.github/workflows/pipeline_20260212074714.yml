name: Weather App Master Framework

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      override_reason:
        description: "Reden voor handmatige goedkeuring (Stakeholder Override)"
        required: false
        default: ""
      run_load_test:
        description: "Voer de k6 Load Test uit?"
        required: true
        type: boolean
        default: false
      run_chaos_test:
        description: "Voer de Chaos Test uit?"
        required: true
        type: boolean
        default: false

# DIT IS DE JUISTE PLEK: Op hetzelfde niveau als 'on' en 'jobs'
env:
  APP_PORT: "57974"
  TEST_URL: "http://localhost:57974"

jobs:
  # STAP 1: Scannen, Bouwen en Pushen (De "Fabriek")
  scan-build-and-push:
    runs-on: self-hosted
    outputs:
      deploy_ver: ${{ steps.versioning.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Nodig voor SonarCloud historie

      - name: üîç Debug Sonar Config
        run: |
          ls -la sonar-project.properties
          cat sonar-project.properties
          pwd

      # 1. EERST Versie bepalen (zodat SonarCloud de versie ook weet)
      - name: üè∑Ô∏è Versioning & HTML Inject
        id: versioning
        run: |
          VERSION_FILE="VERSION"
          CURRENT_VERSION=$(cat $VERSION_FILE 2>/dev/null || echo "2.2.0")
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          COMMIT_MSG=$(git log -1 --pretty=%B)

          if [[ "$COMMIT_MSG" == *"#minor"* ]]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          SEMVER="${MAJOR}.${MINOR}.${PATCH}"
          echo "$SEMVER" > $VERSION_FILE
          # Injectie in HTML
          sed -i.bak "s/{{VERSION}}/${SEMVER}/g" index.html && rm index.html.bak

          echo "APP_VERSION=$SEMVER" >> $GITHUB_ENV
          echo "version=$SEMVER" >> $GITHUB_OUTPUT

      # 2. DAN pas Scannen (met de zojuist gemaakte versie)
      - name: üîç SonarCloud Scan
        uses: sonarsource/sonarqube-scan-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.projectVersion=${{ steps.versioning.outputs.version }}
            -Dsonar.sources=.
            -Dsonar.exclusions=tests/**,**/node_modules/**

      # Image bouwen en naar Docker Hub (of jouw registry)
      - name: üê≥ Build & Push Docker Image
        env:
          # Gebruik de output van de stap 'versioning' in DEZELFDE job
          VERSION: ${{ steps.versioning.outputs.version }}
        run: |
          if [ -z "$VERSION" ]; then
            echo "FOUT: Versie is leeg! Check de versioning stap."
            exit 1
          fi

          echo "Building version: $VERSION"
          # Voeg --build-arg toe om de versie door te geven aan de Dockerfile
          docker build --build-arg APP_VERSION=$VERSION -t mkwaak/weather-app-main:$VERSION .
          docker push mkwaak/weather-app-main:$VERSION

  # STAP 2: De Beveiliger (Start zodra de image er is)
  security-scan:
    needs: scan-build-and-push
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4

      - name: üõ°Ô∏è Trivy Scan
        env:
          # Hier zetten we de versie veilig in een environment variabele
          VERSION: ${{ needs.scan-build-and-push.outputs.deploy_ver }}
        run: |
          mkdir -p tests
          # Gebruik shell-variabele VERSION (zonder krulhaakjes in dit commentaar)
          trivy image --severity HIGH,CRITICAL --exit-code 0 --format json --output tests/security_results.json mkwaak/weather-app-main:$VERSION

      - name: Upload Security Result
        uses: actions/upload-artifact@v4
        with:
          name: security-report
          path: tests/security_results.json

  # STAP 3: De Installateur (Start na de build)
  deploy:
    needs: scan-build-and-push
    runs-on: self-hosted
    outputs:
      service_url: ${{ steps.get_url.outputs.url }}
      actual_port: ${{ steps.get_url.outputs.detected_port }} # NIEUW
    steps:
      - uses: actions/checkout@v4

      - name: ‚ò∏Ô∏è K8s Deploy & Update
        env:
          # Hier definieer je de variabele veilig
          VERSION: ${{ needs.scan-build-and-push.outputs.deploy_ver }}
        run: |
          # Gebruik nu de omgevingsvariabele $VERSION (shell-syntax)
          echo "Deploying version: $VERSION"

          # Werkt op macOS-vriendelijke versie voor de self-hosted runner en op Linux runners
          sed "s|mkwaak/weather-app-main:.*|mkwaak/weather-app-main:$VERSION|g" deployment.yaml > deployment.tmp && mv deployment.tmp deployment.yaml

          # 2. Forceer de update
          kubectl apply -f deployment.yaml

          # Haal de containernaam dynamisch op en gebruik de veilige $VERSION
          CONTAINER_NAME=$(kubectl get deployment weather-app-deployment -o jsonpath='{.spec.template.spec.containers[0].name}')
          kubectl set image deployment/weather-app-deployment $CONTAINER_NAME=mkwaak/weather-app-main:$VERSION

          # 3. Wachten tot het live staat
          kubectl rollout status deployment/weather-app-deployment

      - name: üîó Get Dynamic URL
        id: get_url
        run: |
          # 1. Haal de NodePort op uit de service
          DYNAMIC_PORT=$(kubectl get svc weather-service -o jsonpath='{.spec.ports[0].nodePort}')

          # 2. Bepaal het IP
          if [[ "$OSTYPE" == "darwin"* ]]; then
            TARGET_IP="127.0.0.1"
          else
            TARGET_IP=$(minikube ip)
          fi

          echo "url=http://$TARGET_IP:$DYNAMIC_PORT" >> $GITHUB_OUTPUT
          echo "detected_port=$DYNAMIC_PORT" >> $GITHUB_OUTPUT
          echo "üöÄ App gedetecteerd op: http://$TARGET_IP:$DYNAMIC_PORT"

  # BOLLETJE 4: De Test-Batterij (Inclusief Chaos)
  testing:
    needs: [deploy, security-scan]
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Haal de hele historie op voor Sonar.

      - name: üìÇ Prepare Test Directory
        run: mkdir -p tests

      - name: üì• Download Security Results
        uses: actions/download-artifact@v4
        with:
          name: security-report
          path: tests/

      - name: üö™ Entry Check
        run: |
          echo "Wachten op service op localhost:$APP_PORT..."
          sleep 10

          # We gebruiken hier de globale $APP_PORT variabele van bovenin je YAML
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:$APP_PORT/ || echo "000")

          if [ "$STATUS" == "200" ]; then
            echo "{\"score\": 100, \"detail\": \"App up on port $APP_PORT\"}" > tests/entry_results.json
          else
            echo "{\"score\": 0, \"detail\": \"App unreachable on port $APP_PORT (Status: $STATUS)\"}" > tests/entry_results.json
          fi

      - name: üîç 1. Functional Entry Check
        run: |
          export PATH="$PATH:/Users/marcelkwakernaak/Library/Python/3.9/bin:/usr/local/bin"
          pytest tests/test_entry.py || true

      - name: üåç 2. Location Accuracy Check
        run: |
          python3 tests/location_test.py --url $TEST_URL --output tests/accuracy_results.json

      - name: ‚è≥ Wait for service steady-state
        run: sleep 15

      - name: ‚ö° 3. Performance Benchmark
        if: github.event_name == 'push' || github.event.inputs.run_load_test == 'true'
        run: |
          export PATH="$PATH:/usr/local/bin"
          k6 run -e TEST_URL=$TEST_URL --summary-export=tests/perf_results.json tests/performance_test.js || true

      - name: üèãÔ∏è 4. Load Tests
        if: github.event.inputs.run_load_test == 'true'
        run: |
          export PATH="$PATH:/usr/local/bin"
          k6 run -e TEST_URL=$TEST_URL --summary-export=tests/load_results.json tests/load_test.js || true

      - name: üå™Ô∏è 5. Chaos Test (Resilience)
        if: github.event.inputs.run_chaos_test == 'true'
        run: |
          export PATH="$PATH:/usr/local/bin:/usr/bin"
          echo "Start Chaos Test..."
          k6 run -e TEST_URL=$TEST_URL --summary-export=tests/chaos_results.json tests/load_test.js &
          K6_PID=$!
          sleep 20
          kubectl delete pod -l app=weather-app --now
          wait $K6_PID || true

      - name: üì§ Upload All Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: k6-reports
          path: tests/*.json # Nu pakken we alles in √©√©n keer uit de tests/ map

  # BOLLETJE 5: De Judge (Het Eindstation)
  quality-gate:
    needs: [scan-build-and-push, security-scan, testing] # Zorg dat hij op alles wacht
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4

      - name: üìÇ Create Test Dir
        run: mkdir -p tests # Zorg dat de map er is voor de downloads

      - name: Download Security Report
        uses: actions/download-artifact@v4
        with:
          name: security-report
          path: tests/ # Belangrijk: zet ze in de tests map

      - name: Download k6 Reports
        uses: actions/download-artifact@v4
        with:
          name: k6-reports
          path: tests/ # Belangrijk: zet ze in de tests map

      - name: üèÜ Final Quality Assessment
        env:
          APP_VERSION: ${{ needs.scan-build-and-push.outputs.deploy_ver }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          OVERRIDE_REASON: ${{ github.event.inputs.override_reason }}
        run: |
          python3 tests/calculate_score.py
